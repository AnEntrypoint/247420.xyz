<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.145.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.145.0/examples/jsm/"
      }
    }
  </script>
  <script src="./libs/geckos.io-client.2.1.4.min.js"></script>
  <script src="https://unpkg.com/three@0.145.0/build/three.min.js"></script>
  <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
  <script async src="https://unpkg.com/meshoptimizer@0.18.1/meshopt_decoder.js"></script>
  <script src="/libs/packr.js"></script>

</head>

<body>
  <iframe id="frame" class="frame" width="500" height="500" allow="camera *; microphone *"></iframe>
  
  <script>
    const subdomain = 'demo';
    const frame = document.getElementById('frame');

    frame.src = `https://${subdomain}.readyplayer.me/avatar?frameApi`;

    window.addEventListener('message', subscribe);
    document.addEventListener('message', subscribe);

    function subscribe(event) {
      const json = parse(event);

      if (json?.source !== 'readyplayerme') {
        return;
      }

      // Susbribe to all events sent from Ready Player Me once frame is ready
      if (json.eventName === 'v1.frame.ready') {
        frame.contentWindow.postMessage(
          JSON.stringify({
            target: 'readyplayerme',
            type: 'subscribe',
            eventName: 'v1.**'
          }),
          '*'
        );
      }
    }

    function parse(event) {
      try {
        return JSON.parse(event.data);
      } catch (error) {
        return null;
      }
    }

    function displayIframe() {
      document.getElementById('frame').hidden = false;
    }
  </script>

  <script type="module">

    import * as THREE from 'three';

    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
    import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';

    import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';

    const scene = new THREE.Scene()
    let loader = new GLTFLoader();

    const renderer = new THREE.WebGLRenderer()
    renderer.setSize(window.innerWidth, window.innerHeight)

    const ktx2Loader = new KTX2Loader()
      .setTranscoderPath('https://unpkg.com/three@0.145.0/examples/js/libs/basis/')
      .detectSupport(renderer);


    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath('https://unpkg.com/three@0.145.0/examples/js/libs/draco/');
    dracoLoader.setDecoderConfig({ type: 'js' });
    loader.setMeshoptDecoder(MeshoptDecoder);
    loader.setKTX2Loader(ktx2Loader);
    loader.setDRACOLoader(dracoLoader);
    const loadscene = async (file) => {
      const filescene = await (await fetch(file)).json();
      for (let asset of filescene) {
        if (asset.glb) {
          loader.load(
            asset.glb,
            function (gltf) {
              if(asset.scale?.x) gltf.scene.scale.x = asset.scale.x;
              if(asset.scale?.y) gltf.scene.scale.y = asset.scale.y;
              if(asset.scale?.z) gltf.scene.scale.z = asset.scale.z;
              if(asset.translate?.x) gltf.scene.translate.x = asset.translate.x;
              if(asset.translate?.y) gltf.scene.translate.y = asset.translate.y;
              if(asset.translate?.z) gltf.scene.translate.z = asset.translate.z;
              if(asset.rotate?.x) gltf.scene.rotate.x = asset.rotate.x;
              if(asset.rotate?.y) gltf.scene.rotate.y = asset.rotate.y;
              if(asset.rotate?.z) gltf.scene.rotate.z = asset.rotate.z;
              scene.add(gltf.scene)
            });
        }
      }
    }
    loadscene('assets/town.json');
    const light = new THREE.SpotLight()
    const light2 = new THREE.SpotLight()


    light.position.set(5, 5, 5)
    light2.position.set(5, 5, 5)
    scene.add(light)
    scene.add(light2)

    const environment = new RoomEnvironment();
    const pmremGenerator = new THREE.PMREMGenerator(renderer);

    scene.background = new THREE.Color(0xbbbbbb);
    scene.environment = pmremGenerator.fromScene(environment).texture;
    environment.dispose();


    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    )
    camera.position.z = 20
    camera.position.y = 2

    document.body.appendChild(renderer.domElement)
    const channel = geckos({ url: "https://rtc.lan.247420.xyz", port: 443 })
    let entities = {};
    channel.onConnect(error => {
      if (error) {
        console.error(error.message)
        return
      }
      channel.on('updates', (updates) => {
        for (let e of Object.keys(entities)) {
          if (!updates.filter((u) => { return u.uuid == e }).length) {
            delete entities[e];
          }
        }
        for (let u of updates) {
          if (entities[u.uuid]) {
            entities[u.uuid].position.set(u.pos.x, u.pos.y, u.pos.z)
            entities[u.uuid].quaternion.set(u.quat.x, u.quat.y, u.quat.z, u.quat.w)
          } else {
            entities[u.uuid] = { position: { set: () => { } }, quaternion: { set: () => { } } };
            window.createImageBitmap = undefined;
            loader.load(
              'assets/schwepev2.glb',
              function (gltf) {
                gltf.scene.scale.multiplyScalar(2.0);
                gltf.scene.translateY(50);

                entities[u.uuid] = gltf.scene;
                scene.add(gltf.scene)
              })
          }
        }
      })
    })
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.addEventListener('change', render); // use if there is no animation loop
    controls.minDistance = 10;
    controls.maxDistance = 100;
    controls.target.set(10, 20, - 32);
    controls.update();

    window.addEventListener('resize', onWindowResize, false)
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight
      camera.updateProjectionMatrix()
      renderer.setSize(window.innerWidth, window.innerHeight)
      render()
    }

    function animate() {
      requestAnimationFrame(animate)
      render()
    }

    function render() {
      renderer.render(scene, camera)
    }

    animate()
  </script>
</body>

</html>